<html>
    <head>
        <link rel="stylesheet" href="../../style.css">
        <title>Bot-Star-Horizon</title>

        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    </head>
    <body>
        <a href="../../index.html" class="title-link"><h1>Bot-Star-Horizon</h1></a>

        <h2>Hardness Amplification with ECCs</h2>
        <p class="date">October 6, 2022</p>

        <p>Apparently you can transform worst-case hard functions into average-case hard functions. The definitions are a bit wonky, and I'm still not sure what's the point in \(1-\delta\) error rather than plain and simple \(\frac{1}{2}\pm\delta\) error -- I suppose it makes working with the whole thing easier, but then you're really beating around the bush with the whole `hardness' thing. It's not a matter of what works -- I mean, clearly, this is nitpicking, and I'm probably coming off as an idiot saying this -- but it's a matter of what makes sense <em>cryptographically</em>, and the course I'm taking is supposed to be a complexity course, but who cares.</p>
        <p>Still haven't done my homework. I've told him I'll submit it tomorrow, but at this point I really doubt whether I'm going to submit it tomorrow. I'll submit it <em>sometime</em>, sure -- sometime when I get the answer out of thin air, because I'm not wanting to expend any effort into this course when I could be putting more effort into MPC (which I am currently procrastinating on).</p>
        <p>But the idea is pretty neat. Take a function \(f:\{0,1\}^n\rightarrow\{0,1\}\), encode its truth table as some code \(\hat{f}\subseteq\Sigma^{\hat{n}}\), and it follows that the truth table of any \(\delta\)-distance circuit is going to be <em>decoded</em> back to give you \(f\). It's pretty clever, although it requires some sort of probabilistic decoding mechanism which requires query access to any evaluation of your circuit, so that's where the circuit time/space bound \(t\) or \(s\) come in. It works for Reed-Marshall codes (because of course it works for Reed-Marshall codes).</p>
        <p>Still can't get over the fact that they think \(\mathsf{P}=\mathsf{BPP}\). The fact that randomness confers no additional power seems absurd.</p>

        <h3>Key-Homomorphic PRFs</h3>
        <p>I want a PRF that can do this efficiently:</p>
        <p>$$f(\mathcal{P}(g, x), \mathcal{P}(a, x)) = \mathcal{P}(g^a, x)$$</p>
        <p>Seems like it'd be the holy grail of homomrphic PRFs, and it'd definitely solve my current problem at hand once I've worked out the precise sender-receiver interplay.</p>

        <h3>Goodfellas</h3>
        <p>Against my better judgement, I am watching Goodfellas. Should be studying, really, or sending out emails or something. Not sitting and watching goddamn Goodfellas. Ah, well. RIP Ray Liotta.</p>

        <h3>Rubik's Cube</h3>
        <p>The set of possible moves of a Rubik's cube form a group. Pick a canonical face -- then the set of possible moves is \(\{r, l, u, d, f, b\}\) if you don't count the `middle' movements. The group itself is basically the free group \(F\) generated by the set of moves. Now consider the set \(S\) of all the possible positions that the Rubik's cube could be in. There's a natural group action \(F\rightarrow S\) where each move takes the position to the position you'd get after making that move.</p>
        <p><b>Question:</b> Prove that there's no sequence \(g\in F\) of moves such that applying \(g^n\) to everly element of \(S\) will give the solved cube each time. \(n\) is allowed to be dependent on the element.</p>
        <p class="spoiler">The Rubik's Cube group isn't Abelian, and hence it isn't cyclic.</p>
    </body>
</html>
