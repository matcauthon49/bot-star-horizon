<html>
    <head>
        <link rel="stylesheet" href="../../style.css">
        <title>Bot-Star-Horizon</title>

        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    </head>
    <body>
        <a href="../../index.html" class="title-link"><h1>Bot-Star-Horizon</h1></a>

        <h2>Nobody Knows Anything about Anything</h2>
        <p class="date">October 12, 2022</p>

        <h3>Math</h3>

        <p>I've read three papers over the past week.</p>
        <p>There used to be a time when I considered papers to be sacred documents -- culminations of esoteric ideas brought together into a cohesive whole, decorated around the sides with strokes of genius. Majestic, the product of years of effort, and utterly incomprehensible to undergrads bar Terence Tao. I would waddle through the webpages of famous mathematicians and read the abstracts in an attempt to at least experience those words which would, at some unspecified date far into the future, become objects I would be able to treat with the respect they deserved. (In math, I suppose that's not entirely incorrect. Some of those terms -- `sheaf,' for example -- really <em>do</em> appear to require swathes of time to understand and truly be familiar with. There's a course being offered this semester called GIT and Moduli Theory, and I doubt it'll be much of a jab to say that you need to spend a semester to even get <a href="https://userpage.fu-berlin.de/hoskins/M15_Lecture_notes.pdf">the name of that course</a>.)</p>
        <p>This is not what I would commonly call a misconception, since it does seem like mathematical papers are rigorous and generally inacessible to people outside any particular field. In general, this may or may not be true. <em>I</em> can understand a lot of enumerative combinatorics and graph theory, and I am constantly assured that both number theory and commutative algebra papers are readable by anyone with some level of mathematical maturity, especially post-undergrad. It's the stereotypically deep fields -- algebraic topology, for instance, especially when you get in the thick of higher homotopies or K-theory or whatever simplicial substructure they're attempting to manufacture these days -- that the <em>vagueness</em> begins to set in. This isn't easy. This is for <em>the pros</em>.</p>
        <p>The media does a great job at propogating this image, as by math popularizers' coverage of Fermat's Last Theorem.</p>

        <div class="blue-box">
            <center><h3>Fermat's Last Theorem</h3></center>
            <p>Fermat's Last Theorem is the mathematician's version of a fairy tale. It's a nice story that has all the epic pieces: the prophecy, the quest, and the inevitable payoff in the form of a Abel Prize. Long story short: Pierre de Fermat was a mathematician in the 17th century who, in the margin of Diophantus's <em>Arithmetica</em>, conjectured that</p>
            <p>$$a^n+b^n=c^n$$</p>
            <p>had no solutions for \(n>2\). This turned out to be <a href="https://people.math.wisc.edu/~boston/869.pdf">true, but really, really hard.</a> The proof was given by Andrew Wiles, after he worked on it for about six years in secrecy. His ideas were delivered at a conference in 1993 where he offhandedly remarked at the end that his result implies Fermat's Last Theorem. While the paper itself seems completely indecipherable to me, the major steps involve representing elliptic curves as Galois representations, proving something about the modularity of these curves, and then showing using a contradiction that FLT implies curves which violate such properties.</p>
            <p>FLT is really cool because it's easy to show to non-mathematicians, and to someone who knows little math in the true sense but quite a bit more math than the average person, it seems both impressive and interesting. Add "proof of FLT" to my list of things I want to learn, alongside Algorithmic Game Theory, enumerative combinatorics, and Vakil.</p>
        </div>

        <h3>Computer Science</h3>

        <p>Unfortunately, computer science is not like that.</p>
        <p>Consider cryptography. Genealogically, crypto dates back to <a href="https://en.wikipedia.org/wiki/Manuel_Blum">Manuel Blum</a>, whose students -- Shafi Goldwasser, Silvio Micali, and, to a lesser extent, the Vaziranis -- are responsible for about 50% of the stuff that pure cryptographers do. The other 50% is a wide variety of generally awesome but less immediately flashy people. This means that a large portion of 'top' cryptographers today have a common ancestor back about 3-4 generations at maximum, and if not, you can sure as hell be certain that you ancestors definitely <em>knew</em> (and almost certainly collaborated) with everybody else's ancestors. The subject was literally born in the internet age.</p>
        <p>As a consequence, crypto is <em>new</em>. It's ridiculous just how new it is. The first true paper was published in 1976 with Diffie and Hellman's description of public-key cryptography. Security as a concept didn't come around till the 80s, as did interactive proofs, PCPs, and pseudorandomness. \(\mathsf{PRIMES}\) is in \(\mathsf{P}\) was 2004, \(\mathsf{USTCON\in L}\) was 2008. Hell, even graph algorithms -- much older than modern complexity -- got a result this year, with <a href="https://doi.org/10.48550/arXiv.2203.00671"> Maximum Flows</a> in \(m^{1+o(1)}\) time.</p>
        <p>These problems seem difficult, as does \(\mathsf{P}\) vs \(\mathsf{NP}\). But really, there's no reason that \(\mathsf{P}\) vs \(\mathsf{NP}\) is the computer science equivalent of the Riemann Hypothesis; it's really only the first question we're able to ask, and is probably more in the vein of the insolvability of the quintic. Go deep enough into math, and you start seeing far-reaching theorems and results which combine seemingly disparate fields together in beatiful ways. In CS pretty much all you have is complexity, and apparently it took 40 years to show that \(\mathsf{TC^0\subset\mathsf{NEXP}}.\) That's constant-depth, polysize circuits with access to majority. We know so little it's unreal.</p>
        <p>And this is STEM people, where everything is in an idealized world. The amount of brick walls in theoretical CS is going up, not down. Hmm, is there a theorem for this? Probably not, prove it yourself. I read my first crypto paper in 2021, after less than one year of undergraduate study. You can do complexity in a year, too, and I know a guy who discovered a technique to show that matching is in \(\mathsf{quasi-NC}\) which uses the fact that \(\mathsf{RNC^1\subset RL}\), which is open (and apparently unlikely to be true) after \(<\)2 years of undergraduate study. \(\mathsf{PRIMES\in P}\), a Godel prize winning paper, was Nitin Saxena's B.Tech. thesis.</p>
        <p>You can chalk this off to being in the company of geniuses, but the last time someone showed a substantial algebraic geometry result in a B.Sc. thesis was... well, never, unless maybe you go back to pre-20th century. Grothendeick (the greatest mathematician of the past century to many, although I'm biased to Erdos) took like 7 years or something to come up with his EGA, which was unfinished.</p>
        <p>That's how little computer science we know -- bachelor's students are able to prove Godel Prize-worthy results.</p>
        <p>On the other hand, this is a great thing for people who want to do theoretical computer science, since we're not even close to hitting limits. This isn't theoretical physics; there's stuff happening here at every moment. And sometimes, it's fucking beautiful.</p>

        <h3>Repeated Squaring</h3>

        <p>The amount of haxx in crypto is honestly ridiculous. Here's a result I saw the other day: to show that a prover honestly computed \(b^{2^t}\) successfully, split \(2^t=q\ell+r\), where \(\ell\) is a 'challenge' prime (the verifier issues it as a challenge). Calculate \(b^r\), which is easy, and the prover sends \(\pi=b^q\). The verifier simply needs to compute \(\pi^\ell\times b^r\) and check whether it's the claimed value of \(b^{2^t}\), which the prover can't forge. So simple, so effective. And it's zero-knowledge, too.</p>

    </body>
</html>
